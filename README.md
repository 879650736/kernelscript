# KernelScript

**Advanced Multi-Program eBPF Compiler with Coordinated System Analysis**

KernelScript is a next-generation eBPF compiler that goes beyond single-program compilation to analyze and optimize **entire multi-program eBPF systems**. Unlike traditional eBPF toolchains that treat programs in isolation, KernelScript understands the relationships between programs, detects potential conflicts, and generates coordinated solutions.

## üöÄ Key Advantages

### 1. **Multi-Program System Analysis**

KernelScript analyzes multiple eBPF programs together as a coordinated system, detecting cross-program dependencies, shared map usage patterns, and optimization opportunities.

```kernelscript
map<u32, u32> shared_counter : HashMap(1024) {
  pinned: "/sys/fs/bpf/shared_counter"
};

// XDP program for packet counting
program packet_counter : xdp {
  fn main(ctx: XdpContext) -> XdpAction {
    shared_counter[1] = 100;
    return XDP_PASS;
  }
}

// TC program for packet filtering  
program packet_filter : tc {
  fn main(ctx: TcContext) -> TcAction {
    shared_counter[2] = 200;
    return TC_ACT_OK;
  }
}
```

**KernelScript automatically detects:**
- ‚úÖ **Shared map access patterns** across programs
- ‚ö†Ô∏è  **Potential race conditions** from concurrent map access
- üí° **Optimization opportunities** (e.g., PercpuHash for reduced contention)

### 2. **Intelligent Conflict Detection**

Traditional eBPF compilation treats programs independently, missing critical race conditions. KernelScript's analyzer catches these issues at compile time:

```
=== Multi-Program Analysis Results ===

Programs analyzed: 2
  - packet_counter (xdp)
  - packet_filter (tc)

Global maps: 1
  - shared_counter (hash_map)

‚ö†Ô∏è  Potential conflicts found:
  - Map 'shared_counter' accessed by multiple programs: packet_counter, packet_filter 
    (potential race condition)

üí° Optimization opportunities:
  - Consider using PercpuHash for map 'shared_counter' to reduce contention 
    between programs: packet_counter, packet_filter
```

### 3. **Enhanced Code Generation with Analysis**

Generated eBPF code includes analysis-driven optimizations and comments:

```c
/* Enhanced Multi-Program eBPF System */
/* Programs: 2, Global Maps: 1 */
/* Analysis: Map 'shared_counter' accessed by multiple programs */
/* Optimization: Resource batching applied for coordinated execution */

// XDP program with proper context handling
SEC("xdp")
int packet_counter(struct xdp_md *ctx) {
    // Analysis-optimized map access
    __u32 key = 1;
    __u32 value = 100;
    bpf_map_update_elem(&shared_counter, &key, &value, BPF_ANY);
    return XDP_PASS;  // Analysis-verified return value
}

// TC program with proper context handling  
SEC("tc")
int packet_filter(struct __sk_buff *ctx) {
    __u32 key = 2; 
    __u32 value = 200;
    bpf_map_update_elem(&shared_counter, &key, &value, BPF_ANY);
    return TC_ACT_OK;  // Analysis-verified return value
}
```

### 4. **Automatic Userspace Coordinator Generation**

KernelScript generates sophisticated userspace coordinators that manage multi-program systems:

```c
// Generated coordinator manages multiple programs
static struct bpf_object *bpf_obj = NULL;
static struct bpf_program **bpf_programs = NULL;
static int *prog_fds = NULL;
static int num_programs = 0;

// Enhanced map access with userspace-kernel coordination
int shared_counter_lookup(void *key, void *value) {
    if (shared_counter_fd < 0) return -1;
    return bpf_map_lookup_elem(shared_counter_fd, key, value);
}

int main(int argc, char **argv) {
    // Load all programs from single object file
    if (load_all_bpf_programs() != 0) {
        fprintf(stderr, "Failed to load BPF programs\n");
        return 1;
    }
    
    // Setup shared maps with pinning
    if (setup_maps() != 0) {
        fprintf(stderr, "Failed to setup maps\n");
        return 1;
    }
    
    // Execute coordinated userspace logic
    shared_counter_update(&key_1, &value_1, BPF_ANY);
    shared_counter_update(&key_2, &value_2, BPF_ANY);
    
    return 0;
}
```

### 5. **Complete Build System Generation**

Every compilation produces a ready-to-use project:

```makefile
# Multi-Program eBPF Makefile - Generated by KernelScript

BPF_CC = clang
CC = gcc
BPF_CFLAGS = -target bpf -O2 -Wall -Wextra -g
CFLAGS = -Wall -Wextra -O2
LIBS = -lbpf -lelf -lz

all: multi_programs.ebpf.o multi_programs

multi_programs.ebpf.o: multi_programs.ebpf.c
	$(BPF_CC) $(BPF_CFLAGS) -c $< -o $@

multi_programs: multi_programs.c multi_programs.ebpf.o
	$(CC) $(CFLAGS) -o $@ $< $(LIBS)

run: multi_programs
	sudo ./multi_programs
```

## üõ†Ô∏è Usage

### Basic Compilation
```bash
# Compile with default output directory
kernelscript examples/multi_programs.ks

# Output: multi_programs/ directory with complete project
```

### Custom Output Directory
```bash
# Specify custom output directory
kernelscript -o my_ebpf_project examples/multi_programs.ks

# Output: my_ebpf_project/ directory
```

### Build and Run
```bash
cd multi_programs/
make
sudo ./multi_programs
```

## üéØ What Makes KernelScript Different

| Feature | Traditional eBPF | KernelScript |
|---------|------------------|--------------|
| **Program Analysis** | Single program only | Multi-program system analysis |
| **Conflict Detection** | Manual verification | Automatic race condition detection |
| **Map Coordination** | Manual synchronization | Intelligent shared map management |
| **Code Generation** | Basic templates | Analysis-driven optimization |
| **Userspace Integration** | Manual loader writing | Automatic coordinator generation |
| **Build System** | Manual Makefile | Complete project generation |

## üèóÔ∏è Architecture

KernelScript uses a 6-phase compilation pipeline:

1. **Parsing** - KernelScript syntax to AST
2. **Symbol Analysis** - Build symbol tables and scope resolution  
3. **Multi-Program Analysis** - Detect cross-program dependencies and conflicts
4. **Type Checking** - Enhanced type checking with multi-program context
5. **IR Optimization** - Resource planning and cross-program coordination
6. **Code Generation** - Analysis-aware eBPF and userspace code generation

## üìä Analysis Output Example

```
üöÄ Advanced Multi-Program IR Optimization
==========================================

Step 1: Generating baseline IR...
Step 2: Analyzing optimization opportunities...
Found 3 optimization strategies:
  1. Resource reduction: instruction_count
  2. Cross-program batching: [packet_counter, packet_filter]
  3. Map type optimization: shared_map (HashMap ‚Üí PercpuHash)

Step 3: Applying optimizations...
üîß Optimization: Applying instruction_count reduction
üîß Optimization: Batching programs for coordinated execution
üîß Optimization: Converting map type for reduced contention

Step 4: Cross-program validation...
  ‚úì Validating map access patterns...
  ‚úì Checking resource constraints...
  ‚úì Verifying program dependencies...

Step 5: Resource planning and validation...
  üìä Resource Plan:
     ‚Ä¢ Programs: 2
     ‚Ä¢ Global maps: 1
     ‚Ä¢ Est. instructions: 2000
     ‚Ä¢ Est. stack usage: 1024 bytes
     ‚Ä¢ Est. memory usage: 1048576 bytes
     ‚Ä¢ Verifier compatible: ‚úÖ Yes
```

## üöÄ Getting Started

1. **Clone and build:**
   ```bash
   git clone https://github.com/your-repo/kernelscript
   cd kernelscript
   dune build
   ```

2. **Compile your first multi-program system:**
   ```bash
   dune exec src/main.exe -- examples/multi_programs.ks
   ```

3. **Build and run:**
   ```bash
   cd multi_programs/
   make
   sudo ./multi_programs
   ```

## üéØ Use Cases

- **Network packet processing pipelines** with XDP + TC coordination
- **Security monitoring systems** with multiple probe points
- **Performance profiling** across kernel subsystems  
- **Resource tracking** with shared state management
- **Multi-stage data processing** in kernel space

KernelScript transforms eBPF development from individual program compilation to **coordinated system engineering**.
